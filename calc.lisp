(uiop/package:define-package :xyzzy-calc/calc (:nicknames) (:use :cl) (:shadow)
                             (:export :calc-read-from-string :calc-eval
                              :calc-print)
                             (:intern))
(in-package :xyzzy-calc/calc)
;;don't edit above
(defpackage xyzzy-calc/read
  (:use))

(defvar *calc-package* (find-package :xyzzy-calc/read))
(defvar *calc-token-alist*
  '((#\+ . +)
    (#\- . -)
    (#\* . *) 
    (#\/ . /) 
    (#\% . rem)
    (#\= . =)
    (#\\ . truncate)
    (#\, . comma)
    (#\^ . expt)
    (#\! . !)
    (#\~ . lognot)
    (#\< (#\< . calc-lshift))
    (#\> (#\> . calc-rshift))
    (#\& . logand)
    (#\| . logior)
    (#\` . logxor)
    (#\( . lparen)
    (#\) . rparen)))

(defvar *calc-token-hash* (make-hash-table))

(labels ((set-token-name (c s l)
           (cond ((listp l)
                  (dolist (x l)
                    (set-token-name (car x) (cons c s) (cdr x))))
                 (s
                  (setf (gethash l *calc-token-hash*)
                        (format nil "~{~a~}~a" (reverse s) (if c c ""))))
                 (t
                  (setf (gethash l *calc-token-hash*) c)))))
  (dolist (x *calc-token-alist*)
    (set-token-name (car x) nil (cdr x))))

(defvar *calc-bits* nil)
(defvar *calc-radix* 10)
(defvar *calc-unsigned* nil)
(defvar *calc-ratio* 'ratio)

(defvar *calc-token* nil)

(defconstant xyzzy-calc/read::pi pi)
(defconstant xyzzy-calc/read::e (exp 1.0d0))

(setf (symbol-function 'xyzzy-calc/read::gcd) #'gcd)
(setf (symbol-function 'xyzzy-calc/read::lcm) #'lcm)
(setf (symbol-function 'xyzzy-calc/read::exp) #'exp)
(setf (symbol-function 'xyzzy-calc/read::expt) #'expt)
(setf (symbol-function 'xyzzy-calc/read::pow) #'expt)
(setf (symbol-function 'xyzzy-calc/read::log) #'log)
(setf (symbol-function 'xyzzy-calc/read::log10) #'(lambda (x) (log (float x 0d0) 10d0)))
(setf (symbol-function 'xyzzy-calc/read::sqrt) #'sqrt)
(setf (symbol-function 'xyzzy-calc/read::isqrt) #'isqrt)
(setf (symbol-function 'xyzzy-calc/read::abs) #'abs)
(setf (symbol-function 'xyzzy-calc/read::sin) #'sin)
(setf (symbol-function 'xyzzy-calc/read::cos) #'cos)
(setf (symbol-function 'xyzzy-calc/read::tan) #'tan)
(setf (symbol-function 'xyzzy-calc/read::asin) #'asin)
(setf (symbol-function 'xyzzy-calc/read::acos) #'acos)
(setf (symbol-function 'xyzzy-calc/read::atan) #'atan)
(setf (symbol-function 'xyzzy-calc/read::atan2) #'(lambda (y x) (atan y x)))
(setf (symbol-function 'xyzzy-calc/read::sinh) #'sinh)
(setf (symbol-function 'xyzzy-calc/read::cosh) #'cosh)
(setf (symbol-function 'xyzzy-calc/read::tanh) #'tanh)
(setf (symbol-function 'xyzzy-calc/read::asinh) #'asinh)
(setf (symbol-function 'xyzzy-calc/read::acosh) #'acosh)
(setf (symbol-function 'xyzzy-calc/read::atanh) #'atanh)
(setf (symbol-function 'xyzzy-calc/read::floor) #'floor)
(setf (symbol-function 'xyzzy-calc/read::ceil) #'ceiling)
(setf (symbol-function 'xyzzy-calc/read::ceiling) #'ceiling)
(setf (symbol-function 'xyzzy-calc/read::trunc) #'truncate)
(setf (symbol-function 'xyzzy-calc/read::truncate) #'truncate)
(setf (symbol-function 'xyzzy-calc/read::round) #'round)
(setf (symbol-function 'xyzzy-calc/read::rem) #'rem)
(setf (symbol-function 'xyzzy-calc/read::mod) #'mod)
(setf (symbol-function 'xyzzy-calc/read::ffloor) #'ffloor)
(setf (symbol-function 'xyzzy-calc/read::fceiling) #'fceiling)
(setf (symbol-function 'xyzzy-calc/read::fceil) #'fceiling)
(setf (symbol-function 'xyzzy-calc/read::ftruncate) #'ftruncate)
(setf (symbol-function 'xyzzy-calc/read::ftrunc) #'ftruncate)
(setf (symbol-function 'xyzzy-calc/read::fround) #'fround)
(setf (symbol-function 'xyzzy-calc/read::float) #'(lambda (x) (float x 0d0)))
(setf (symbol-function 'xyzzy-calc/read::int) #'truncate)
(setf (symbol-function 'xyzzy-calc/read::ratio) #'rationalize)
(setf (symbol-function 'xyzzy-calc/read::complex) #'complex)
(setf (symbol-function 'xyzzy-calc/read::phase) #'phase)
(setf (symbol-function 'xyzzy-calc/read::cis) #'cis)
(setf (symbol-function 'xyzzy-calc/read::min) #'min)
(setf (symbol-function 'xyzzy-calc/read::max) #'max)
(setf (symbol-function 'xyzzy-calc/read::conjugate) #'conjugate)
(setf (symbol-function 'xyzzy-calc/read::signum) #'signum)
(setf (symbol-function 'xyzzy-calc/read::sign) #'signum)
(setf (symbol-function 'xyzzy-calc/read::realpart) #'realpart)
(setf (symbol-function 'xyzzy-calc/read::real) #'realpart)
(setf (symbol-function 'xyzzy-calc/read::imagpart) #'imagpart)
(setf (symbol-function 'xyzzy-calc/read::imag) #'imagpart)
(setf (symbol-function 'xyzzy-calc/read::numerator) #'numerator)
(setf (symbol-function 'xyzzy-calc/read::num) #'numerator)
(setf (symbol-function 'xyzzy-calc/read::denominator) #'denominator)
(setf (symbol-function 'xyzzy-calc/read::den) #'denominator)
(setf (symbol-function 'xyzzy-calc/read::ash) #'ash)
(setf (symbol-function 'xyzzy-calc/read::shift) #'ash)
(setf (symbol-function 'xyzzy-calc/read::random) #'random)
(setf (symbol-function 'xyzzy-calc/read::rand) #'random)

(defun xyzzy-calc/read::fibonacci (n)
  (check-type n integer)
  (cond ((not (plusp n))
         (error 'range-error :datum n))
        ((= n 1) 1)
        ((= n 2) 1)
        (t
         (do* ((f1 1 f2)
               (f2 1 f)
               (f (+ f1 f2) (+ f1 f2))
               (x 3 (+ x 1)))
             ((>= x n) f)))))

(setf (symbol-function 'xyzzy-calc/read::fib) #'xyzzy-calc/read::fibonacci)

(defun calc-fact (n)
  (check-type n integer)
  (when (minusp n)
    (error 'range-error :datum n))
  (do* ((i 1 (+ i 1))
        (r 1 (* i r)))
      ((>= i n) r)))

(setf (symbol-function 'xyzzy-calc/read::fact) #'calc-fact)

(defmacro xyzzy-calc/read::sigma (var from to sexp)
  `(do ((,var ,from (1+ ,var))
        (#1=#:sum 0))
       ((> ,var ,to) #1#)
     (setq #1# (+ #1# ,sexp))))

(setf (symbol-function 'calc-lshift) #'ash)
(defun calc-rshift (x y) (ash x (- y)))

(defun calc-token-string (x)
  (or (and (symbolp x) (gethash x *calc-token-hash*)) x ""))

(defun calc-get-token (c s fn)
  (with-output-to-string (so)
    (when c
      (write-char c so))
    (loop
      (setq c (read-char s nil nil))
      (unless c
        (return))
      (unless (funcall fn c)
        (unread-char c s)
        (return))
      (write-char c so))))

(defun calc-next-token (s)
  (loop
    (let ((c (read-char s nil nil)))
      (cond ((null c)
             (return nil))
            ((let ((tok (assoc c *calc-token-alist*)))
               (when tok
                 (return (loop
                           (let ((al (cdr tok)))
                             (unless (listp al)
                               (return al))
                             (setq c (read-char s nil nil))
                             (setq tok (assoc c al))
                             (unless tok
                               (setq tok (assoc nil al))
                               (cond ((null tok)
                                      (if c
                                          (error "syntax error: ~c" c)
                                          (error "unexpected eol")))
                                     (c
                                      (unread-char c s))))))))))
            ((or (digit-char-p c)
                 (char= c #\.))
             (when (char= c #\0)
               (let ((c (read-char s nil nil)))
                 (unless c
                   (return 0))
                 (let ((base (cond ((char-equal c #\x) 16)
                                   ((char-equal c #\b) 2)
                                   ((digit-char-p c 8)
                                    (unread-char c s)
                                    8)
                                   (t
                                    (unread-char c s)
                                    nil))))
                   (when base
                     (return (parse-integer
                              (calc-get-token nil s
                                              #'(lambda (c)
                                                  (digit-char-p c base)))
                              :radix base))))))
             (let ((state 'leadnum)
                   (invalid-p nil))
               (flet ((flonum (c)
                        (setq state
                              (cond ((digit-char-p c)
                                     (case state
                                       ((leadnum trailnum expnum) state)
                                       (dot 'trailnum)
                                       ((expchar expsign) 'expnum)))
                                    ((char= c #\.)
                                     (case state
                                       (leadnum 'dot)
                                       (t (setq invalid-p state))))
                                    ((char-equal c #\e)
                                     (case state
                                       ((leadnum dot trailnum) 'expchar)
                                       ((expchar expsign)
                                        (setq invalid-p state))
                                       (expnum nil)))
                                    ((or (char= c #\+)
                                         (char= c #\-))
                                     (case state
                                       ((leadnum dot trailnum expnum) nil)
                                       (expchar 'expsign)
                                       (t (setq invalid-p state))))
                                    (t
                                     (case state
                                       ((leadnum dot trailnum expnum) nil)
                                       (t (setq invalid-p state))))))))
                 (flonum c)
                 (let* ((tok (read-from-string (calc-get-token c s #'flonum))))
                   (when (or invalid-p (not (numberp tok)))
                     (error "invalid format: ~a" tok))
                   (return tok)))))
            ((find c " \t\n\r\f"))
            ((or (alpha-char-p c)
                 (>= (char-code c) 127)
                 (char= c #\_))
             (return (uiop:safe-read-from-string
                      (format nil "~A::~A"
                              (package-name *calc-package*)
                              (calc-get-token c s #'(lambda (c)
                                                      (or (alphanumericp c)
                                                          (>= (char-code c) 127)
                                                          (char= c #\_))))))))
            (t
             (error "syntax error: ~c" c))))))

(defmacro calc-assoc-left (name next operators)
  `(defun ,name ()
     (let ((left (,next)))
       (loop while (,(if (listp operators) 'member 'eq) (car *calc-token*) ',operators)
             do (setq left `(,(pop *calc-token*) ,left ,(,next))))
       left)))

(defmacro calc-assoc-right (name next operators)
  `(defun ,name ()
     (let ((left (,next)))
       (if (,(if (listp operators) 'member 'eq) (car *calc-token*) ',operators)
           `(,(pop *calc-token*) ,left ,(,name))
           left))))

(defun calc-expr ()
  (calc-assign-expr))

(defun calc-expr-list ()
  (when (eq (car *calc-token*) 'rparen)
    (pop *calc-token*)
    (return-from calc-expr-list nil))
  (let ((list nil))
    (loop
      (push (calc-expr) list)
      (cond ((eq (car *calc-token*) 'comma)
             (pop *calc-token*))
            ((eq (car *calc-token*) 'rparen)
             (pop *calc-token*)
             (return (nreverse list)))
            (t
             (error ") expected."))))))

(defun calc-primary-expr ()
  (let ((tok (car *calc-token*)))
    (cond ((numberp tok)
           (pop *calc-token*)
           tok)
          ((and (symbolp tok)
                (eq (symbol-package tok) *calc-package*))
           (pop *calc-token*)
           (cond ((eq (car *calc-token*) 'lparen)
                  (pop *calc-token*)
                  `(,tok ,@(calc-expr-list)))
                 (t tok)))
          ((eq (car *calc-token*) 'lparen)
           (pop *calc-token*)
           (prog1
               (calc-expr)
             (unless (eq (pop *calc-token*) 'rparen)
               (error ") expected."))))
          (t (error "primary expected: ~a" (calc-token-string tok))))))

(defun calc-postfix-expr ()
  (let ((expr (calc-primary-expr)))
    (loop while (eq (car *calc-token*) '!)
          do (pop *calc-token*)
             (setq expr `(calc-fact ,expr)))
    expr))

(defun calc-unary-expr ()
  (if (member (car *calc-token*) '(+ - lognot))
      `(,(pop *calc-token*) ,(calc-unary-expr))
      (calc-postfix-expr)))

(calc-assoc-right calc-power-expr calc-unary-expr expt)

(defun calc-multiplicative-expr ()
  (let ((left (calc-power-expr)))
    (loop
      (let ((ope (car *calc-token*)))
        (cond ((null ope)
               (return left))
              ((member ope '(* / rem truncate))
               (setq left `(,(pop *calc-token*) ,left ,(calc-power-expr))))
              ((or (and (eq ope 'lparen)
                        (not (symbolp left)))
                   (not (and (symbolp ope)
                             (gethash ope *calc-token-hash*))))
               (setq left `(* ,left ,(calc-power-expr))))
              (t
               (return left)))))))

(calc-assoc-left calc-additive-expr calc-multiplicative-expr (+ -))
(calc-assoc-left calc-shift-expr calc-additive-expr (calc-lshift calc-rshift))
(calc-assoc-left calc-logand-expr calc-shift-expr logand)
(calc-assoc-left calc-logxor-expr calc-logand-expr logxor)
(calc-assoc-left calc-logior-expr calc-logxor-expr logior)

(defun calc-assign-expr ()
  (let ((left (calc-logior-expr)))
    (cond ((eq (car *calc-token*) '=)
           (pop *calc-token*)
           (let ((right (calc-assign-expr)))
             (cond ((symbolp left)
                    `(setq ,left ,right))
                   #+nil((and (listp left)
                         (symbolp (car left))
                         (eq (symbol-package (car left)) *calc-package*))
                    (dolist (x (cdr left))
                      (or (symbolp x)
                          (error "syntax error: ~a" (calc-token-string x))))
                    (setf (symbol-function (car left)) `(lambda ,(cdr left) ,right))
                    'function)
                   (t
                    (error "left operand must be l-value")))))
          (t left))))

(defun calc-options (args)
  (cond (args
         (loop while args
               do (let ((var (pop args))
                        (val (when (eq (car args) '=)
                               (pop args)
                               (pop args))))
                    (cond ((eq var 'xyzzy-calc/read::bits)
                           (setq *calc-bits*
                                 (cond ((member val '(16 32 64)) val)
                                       ((or (null val) (eq val 'xyzzy-calc/read::unlimit)) nil)
                                       (t (error "invalid bits: ~a" (calc-token-string val))))))
                          ((eq var 'xyzzy-calc/read::radix)
                           (setq *calc-radix*
                                 (cond ((member val '(2 8 10 16)) val)
                                       ((eq val 'xyzzy-calc/read::bin) 2)
                                       ((eq val 'xyzzy-calc/read::oct) 8)
                                       ((eq val 'xyzzy-calc/read::dec) 10)
                                       ((eq val 'xyzzy-calc/read::hex) 16)
                                       (t (error "invalid radix: ~a" (calc-token-string val))))))
                          ((eq var 'xyzzy-calc/read::signed)
                           (setq *calc-unsigned* nil))
                          ((eq var 'xyzzy-calc/read::unsigned)
                           (setq *calc-unsigned* t))
                          ((eq var 'xyzzy-calc/read::ratio)
                           (setq *calc-ratio*
                                 (cond ((eq val 'xyzzy-calc/read::int) 'int)
                                       ((eq val 'xyzzy-calc/read::ratio) 'ratio)
                                       ((eq val 'xyzzy-calc/read::float) 'float)
                                       ((null val) *calc-ratio*)
                                       (t (error "invalid ratio: ~a" (calc-token-string val))))))
                          (t
                           (error "unknown option: ~a" (calc-token-string var))))))
         nil)
        (t
         (format nil "bits=~a radix=~a ~a ratio=~a"
                 (if *calc-bits* *calc-bits* 'unlimit)
                 *calc-radix* (if *calc-unsigned* 'unsigned 'signed) *calc-ratio*))))

(defun calc-read (s)
  (let ((token nil))
    (do ((tok (calc-next-token s) (calc-next-token s)))
        ((null tok) (nreverse token))
      (push tok token))))

(defun calc-read-from-string (string)
  (with-input-from-string (s string)
    (calc-read s)))

(defun calc-eval (*calc-token*)
  (let (result)
    (handler-case
        (setf result (let ((*read-default-float-format* 'double-float))
                       (if (eq (car *calc-token*) 'xyzzy-calc/read::set)
                           (calc-options (cdr *calc-token*))
                           (let ((expr (and *calc-token* (calc-expr))))
                             (when *calc-token*
                               (error "unexpected ~a." (calc-token-string (car *calc-token*))))
                             (eval expr)))))
      (error (c)
        (setq result (format nil "~s" c))))
    result))

(defun calc-print-number (x o)
  (cond ((complexp x)
         (format o "complex(")
         (calc-print-number (realpart x) o)
         (format o ", ")
         (calc-print-number (imagpart x) o)
         (format o ")"))
        ((and (rationalp x) (not (integerp x)))
         (calc-print-number (numerator x) o)
         (format o "/")
         (calc-print-number (denominator x) o))
        ((integerp x)
         (cond ((eql *calc-radix* 2)
                (format o "0b~b" x))
               ((eql *calc-radix* 8)
                (format o "0~o" x))
               ((eql *calc-radix* 16)
                (format o "0x~x" x))
               (t
                (format o "~d" x))))
        (t
         (let ((*read-default-float-format* 'double-float))
           (format o"~a" x)))))

(defun calc-print (result &optional (o *standard-output*))
  (when result
    (when (rationalp  result)
      (cond ((eq *calc-ratio* 'int)
             (setq result (truncate result)))
            ((eq *calc-ratio* 'float)
             (setq result (float result 1d0)))))
    (when (and (integerp result) *calc-bits*)
      (setq result (logand result (- (ash 1 *calc-bits*) 1)))
      (when (and (null *calc-unsigned*)
                 (logbitp (- *calc-bits* 1) result))
        (setq result (- result (ash 1 *calc-bits*)))))
    (calc-print-number result o)))
